[{"title":"如何定义一个高逼格的原生JS插件","date":"2017-04-04T16:00:00.000Z","path":"2017/04/05/JS-Plugins/","text":"作为一个前端er，如果不会写一个小插件，都不好意思说自己是混前端界的。写还不能依赖jquery之类的工具库，否则装得不够高端。那么，如何才能装起来让自己看起来逼格更高呢？当然是利用js纯原生的写法啦。以前一直说，掌握了js原生，就基本上可以解决前端的所有脚本交互工作了，这话大体上是有些浮夸了。不过，也从侧面说明了原生js在前端中占着多么重要的一面。好了。废话不多说。咱们就来看一下怎么去做一个自己的js插件吧。 插件的需求我们写代码，并不是所有的业务或者逻辑代码都要抽出来复用。首先，我们得看一下是否需要将一部分经常重复的代码抽象出来，写到一个单独的文件中为以后再次使用。再看一下我们的业务逻辑是否可以为团队服务。插件不是随手就写成的，而是根据自己业务逻辑进行抽象。没有放之四海而皆准的插件，只有对插件，之所以叫做插件，那么就是开箱即用，或者我们只要添加一些配置参数就可以达到我们需要的结果。如果都符合了这些情况，我们才去考虑做一个插件。 插件封装的条件一个可复用的插件需要满足以下条件： 插件自身的作用域与用户当前的作用域相互独立，也就是插件内部的私有变量不能影响使用者的环境变量； 插件需具备默认设置参数； 插件除了具备已实现的基本功能外，需提供部分API，使用者可以通过该API修改插件功能的默认参数，从而实现用户自定义插件效果； 插件需提供监听入口，及针对指定元素进行监听，使得该元素与插件响应达到插件效果； 插件支持链式调用。 关于插件封装的条件，可以查看一篇文章：原生JavaScript插件编写指南而我想要说明的是，如何一步一步地实现我的插件封装。所以，我会先从简单的方法函数来做起。 插件的外包装用函数包装所谓插件，其实就是封装在一个闭包中的一种函数集。我记得刚开始写js的时候，我是这样干的，将我想要的逻辑，写成一个函数，然后再根据不同需要传入不同的参数就可以了。比如，我想实现两个数字相加的方法： function add(n1,n2) { return n1 + n2; } // 调用 add(1,2) // 输出：3 这就是我们要的功能的简单实现。如果仅仅只不过实现这么简单的逻辑，那已经可以了，没必要弄一些花里胡哨的东西。js函数本身就可以解决绝大多数的问题。不过我们在实际工作与应用中，一般情况的需求都是比较复杂得多。如果这时，产品来跟你说，我不仅需要两个数相加的，我还要相减，相乘，相除，求余等等功能。这时候，我们怎么办呢？当然，你会想，这有什么难的。直接将这堆函数都写出来不就完了。然后都放在一个js文件里面。需要的时候，就调用它就好了。 // 加 function add(n1,n2) { return n1 + n2; } // 减 function sub(n1,n2) { return n1 - n2; } // 乘 function mul(n1,n2) { return n1 * n2; } // 除 function div(n1,n2) { return n1 / n2; } // 求余 function sur(n1,n2) { return n1 % n2; } OK，现在已经实现我们所需要的所有功能。并且我们也把这些函数都写到一个js里面了。如果是一个人在用，那么可以很清楚知道自己是否已经定义了什么，并且知道自己写了什么内容，我在哪个页面需要，那么就直接引入这个js文件就可以搞定了。不过，如果是两个人以上的团队，或者你与别人一起协作写代码，这时候，另一个人并不知道你是否写了add方法，这时他也定义了同样的add方法。那么你们之间就会产生命名冲突，一般称之为变量的 全局污染 用全局对象包装为了解决这种全局变量污染的问题。这时，我们可以定义一个js对象来接收我们这些工具函数。 var plugin = { add: function(n1,n2){...},//加 sub: function(n1,n2){...},//减 mul: function(n1,n2){...},//乘 div: function(n1,n2){...},//除 sur: function(n1,n2){...} //余 } // 调用 plugin.add(1,2) 上面的方式，约定好此插件名为plugin，让团队成员都要遵守命名规则，在一定程度上已经解决了全局污染的问题。在团队协作中只要约定好命名规则了，告知其它同学即可以。当然不排除有个别人，接手你的项目，并不知道此全局变量已经定义，则他又定义了一次并赋值，这时，就会把你的对象覆盖掉。当然，可能你会这么干来解决掉命名冲突问题： if(!plugin){ //这里的if条件也可以用： (typeof plugin == 'undefined') var plugin = { // 以此写你的函数逻辑 } } 或者也可以这样写： var plugin; if(!plugin){ plugin = { // ... } } 这样子，就不会存在命名上的冲突了。 也许有同学会疑问，为什么可以在此声明plugin变量？实际上js的解释执行，会把所有声明都提前。如果一个变量已经声明过，后面如果不是在函数内声明的，则是没有影响的。所以，就算在别的地方声明过var plugin，我同样也以可以在这里再次声明一次。关于声明的相关资料可以看阮一锋的如何判断Javascript对象是否存在。 基本上，这就可以算是一个插件了。解决了全局污染问题，方法函数可以抽出来放到一单独的文件里面去。 利用闭包包装上面的例子，虽然可以实现了插件的基本上的功能。不过我们的plugin对象，是定义在全局域里面的。我们知道，js变量的调用，从全局作用域上找查的速度会比在私有作用域里面慢得多得多。所以，我们最好将插件逻辑写在一个私有作用域中。实现私有作用域，最好的办法就是使用闭包。可以把插件当做一个函数，插件内部的变量及函数的私有变量，为了在调用插件后依旧能使用其功能，闭包的作用就是延长函数(插件)内部变量的生命周期，使得插件函数可以重复调用，而不影响用户自身作用域。故需将插件的所有功能写在一个立即执行函数中： ;(function(global,undefined) { var plugin = { add: function(n1,n2){...} ... } // 最后将插件对象暴露给全局对象 'plugin' in global &amp;&amp; global.plugin = plugin; })(window); 对上面的代码段传参问题进行解释一下： 在定义插件之前添加一个分号，可以解决js合并时可能会产生的错误问题； undefined在老一辈的浏览器是不被支持的，直接使用会报错，js框架要考虑到兼容性，因此增加一个形参undefined，就算有人把外面的 undefined 定义了，里面的 undefined 依然不受影响； 把window对象作为参数传入，是避免了函数执行的时候到外部去查找。 其实，我们觉得直接传window对象进去，我觉得还是不太妥当。我们并不确定我们的插件就一定用于浏览器上，也有可能使用在一些非浏览端上。所以我们还可以这么干，我们不传参数，直接取当前的全局this对象为作顶级对象用。 ;(function(global,undefined) { \"use strict\" //使用js严格模式检查，使语法更规范 var _global; var plugin = { add: function(n1,n2){...} ... } // 最后将插件对象暴露给全局对象 _global = (function(){ return this || (0, eval)('this'); }()); !('plugin' in _global) &amp;&amp; (_global.plugin = plugin); }()); 如此，我们不需要传入任何参数，并且解决了插件对环境的依事性。如此我们的插件可以在任何宿主环境上运行了。 上面的代码段中有段奇怪的表达式：(0, eval)(&#39;this&#39;)，实际上(0,eval)是一个表达式，这个表达式执行之后的结果就是eval这一句相当于执行eval(&#39;this&#39;)的意思，详细解释看此篇：(0,eval)(‘this’)释义或者看一下这篇(0,eval)(‘this’) 关于立即自执行函数，有两种写法： // 写法一 (function(){})() //写法二 (function(){}()) 上面的两种写法是没有区别的。都是正确的写法。个人建议使用第二种写法。这样子更像一个整体。 附加一点知识：js里面()括号就是将代码结构变成表达式，被包在()里面的变成了表达式之后，则就会立即执行，js中将一段代码变成表达式有很多种方式，比如： void function(){...}(); // 或者 !function foo(){...}(); // 或者 +function foot(){...}(); 当然，我们不推荐你这么用。而且乱用可能会产生一些歧义。 到这一步，我们的插件的基础结构就已经算是完整的了。 使用模块化的规范包装虽然上面的包装基本上已经算是ok了的。但是如果是多个人一起开发一个大型的插件，这时我们要该怎么办呢？多人合作，肯定会产生多个文件，每个人负责一个小功能，那么如何才能将所有人开发的代码集合起来呢？这是一个讨厌的问题。要实现协作开发插件，必须具备如下条件： 每功能互相之间的依赖必须要明确，则必须严格按照依赖的顺序进行合并或者加载 每个子功能分别都要是一个闭包，并且将公共的接口暴露到共享域也即是一个被主函数暴露的公共对象 关键如何实现，有很多种办法。最笨的办法就是按顺序加载js &lt;script type=\"text/javascript\" src=\"part1.js\">&lt;/script> &lt;script type=\"text/javascript\" src=\"part2.js\">&lt;/script> &lt;script type=\"text/javascript\" src=\"part3.js\">&lt;/script> ... &lt;script type=\"text/javascript\" src=\"main.js\">&lt;/script> 但是不推荐这么做，这样做与我们所追求的插件的封装性相背。不过现在前端界有一堆流行的模块加载器，比如require、seajs，或者也可以像类似于Node的方式进行加载，不过在浏览器端，我们还得利用打包器来实现模块加载，比如browserify。不过在此不谈如何进行模块化打包或者加载的问题，如有问题的同学可以去上面的链接上看文档学习。为了实现插件的模块化并且让我们的插件也是一个模块，我们就得让我们的插件也实现模块化的机制。我们实际上，只要判断是否存在加载器，如果存在加载器，我们就使用加载器，如果不存在加载器。我们就使用顶级域对象。 if (typeof module !== \"undefined\" &amp;&amp; module.exports) { module.exports = plugin; } else if (typeof define === \"function\" &amp;&amp; define.amd) { define(function(){return plugin;}); } else { _globals.plugin = plugin; } 这样子我们的完整的插件的样子应该是这样子的： // plugin.js ;(function(undefined) { \"use strict\" var _global; var plugin = { add: function(n1,n2){ return n1 + n2; },//加 sub: function(n1,n2){ return n1 - n2; },//减 mul: function(n1,n2){ return n1 * n2; },//乘 div: function(n1,n2){ return n1 / n2; },//除 sur: function(n1,n2){ return n1 % n2; } //余 } // 最后将插件对象暴露给全局对象 _global = (function(){ return this || (0, eval)('this'); }()); if (typeof module !== \"undefined\" &amp;&amp; module.exports) { module.exports = plugin; } else if (typeof define === \"function\" &amp;&amp; define.amd) { define(function(){return plugin;}); } else { !('plugin' in _global) &amp;&amp; (_global.plugin = plugin); } }()); 我们引入了插件之后，则可以直接使用plugin对象。 with(plugin){ console.log(add(2,1)) // 3 console.log(sub(2,1)) // 1 console.log(mul(2,1)) // 2 console.log(div(2,1)) // 2 console.log(sur(2,1)) // 0 } 插件的API插件的默认参数我们知道，函数是可以设置默认参数这种说法，而不管我们是否传有参数，我们都应该返回一个值以告诉用户我做了怎样的处理，比如： function add(param){ var args = !!param ? Array.prototype.slice.call(arguments) : []; return args.reduce(function(pre,cur){ return pre + cur; }, 0); } console.log(add()) //不传参，结果输出0，则这里已经设置了默认了参数为空数组 console.log(add(1,2,3,4,5)) //传参，结果输出15 则作为一个健壮的js插件，我们应该把一些基本的状态参数添加到我们需要的插件上去。假设还是上面的加减乘除余的需求，我们如何实现插件的默认参数呢？道理其实是一样的。 // plugin.js ;(function(undefined) { \"use strict\" var _global; function result(args,fn){ var argsArr = Array.prototype.slice.call(args); if(argsArr.length > 0){ return argsArr.reduce(fn); } else { return 0; } } var plugin = { add: function(){ return result(arguments,function(pre,cur){ return pre + cur; }); },//加 sub: function(){ return result(arguments,function(pre,cur){ return pre - cur; }); },//减 mul: function(){ return result(arguments,function(pre,cur){ return pre * cur; }); },//乘 div: function(){ return result(arguments,function(pre,cur){ return pre / cur; }); },//除 sur: function(){ return result(arguments,function(pre,cur){ return pre % cur; }); } //余 } // 最后将插件对象暴露给全局对象 _global = (function(){ return this || (0, eval)('this'); }()); if (typeof module !== \"undefined\" &amp;&amp; module.exports) { module.exports = plugin; } else if (typeof define === \"function\" &amp;&amp; define.amd) { define(function(){return plugin;}); } else { !('plugin' in _global) &amp;&amp; (_global.plugin = plugin); } }()); // 输出结果为： with(plugin){ console.log(add()); // 0 console.log(sub()); // 0 console.log(mul()); // 0 console.log(div()); // 0 console.log(sur()); // 0 console.log(add(2,1)); // 3 console.log(sub(2,1)); // 1 console.log(mul(2,1)); // 2 console.log(div(2,1)); // 2 console.log(sur(2,1)); // 0 } 插件的API接口我们知道，设计一下插件，肯定不是死的，我们得像函数一样，得让用户提供自己的参数去实现用户的需求。则我们的插件需要提供一个修改默认参数的入口。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://huangguangjie.github.io/tags/javascript/"},{"name":"插件","slug":"插件","permalink":"https://huangguangjie.github.io/tags/插件/"},{"name":"自定义","slug":"自定义","permalink":"https://huangguangjie.github.io/tags/自定义/"}]},{"title":"从实际应用中去理解Promise","date":"2017-04-01T16:00:00.000Z","path":"2017/04/02/promise/","text":"在es6使用已经很普遍的今天，我再说Promise各种API及其原理的话也不过是锦上添花。Promise的重要性，我们不必多讲，相信大家都知道出现Promise的意义及其对js异步编程上的作用是多么巨大。不过，说真，要真正去理解使用这个对象，确实是有些困难，特别是对我这种理解新东西总是有困难症的人来说更甚。所以，我的办法就是重重复复地看相关的文章及api文档，以达到自己能使用及理解。在理解Promise之前，先来看一下异步的实现过程。 为什么要用Promise在说Promise之前，我们得先来确定一下为什么要有这个对象。 原生JS实现一个简单的ajax说到浏览器异步处理中，ajax可以说是最基本的异步编程方法了，可以简单实现为： //此实现，只是简单实现，未实现兼容处理 var url = '&lt;url>'; var result; var XHR = new XMLHttpRequest(); XHR.open('GET', url, true); XHR.send(); XHR.onreadystatechange = function() { if (XHR.readyState == 4 &amp;&amp; XHR.status == 200) { result = XHR.response; console.log(result); } } 在ajax的原生实现中，利用了onreadystatechange事件，当该事件触发且符合一定条件时，才能拿到我们想要的数据。之后我们才能开始执行回调里面的代码。这看上去并没有什么麻烦的，但是如果这时，我们想有两个ajax请求，并且还得有先后顺序进执行。我们这时会这样做。 var url = '&lt;url>'; var result; var XHR = new XMLHttpRequest(); XHR.open('GET', url, true); XHR.send(); XHR.onreadystatechange = function() { if (XHR.readyState == 4 &amp;&amp; XHR.status == 200) { result = XHR.response; console.log(result); // 在此重复上面的逻辑 var url2 = '&lt;url>'; var result2; var XHR2 = new XMLHttpRequest(); XHR2.open('GET', url, true); XHR2.send(); XHR2.onreadystatechange = function() { if (XHR.readyState == 4 &amp;&amp; XHR.status == 200) { result = XHR.response; console.log(result); } } } } 当出现第三个ajax（甚至更多）仍然依赖上面的方法做，那将是一场灾难。这样的灾难，往往被称为 回调地狱 因此，我们需要消除掉回调地狱这个问题。当然，除了消除回调地狱之外，还一个非常重要的需求： 为了我们的代码更加具有可读性与可维护性，我们需要将数据请求与数据处理逻辑区分开来 。上面的写法，是完全没有区分开的，当数据变得复杂，处理逻辑就更加复杂，到时我们就没法维护我们写的代码了。（为了代码简洁性，部分代码使用es6的写法） 函数调用栈我们可以通过利用函数调用栈，将我们想要代码放到回调函数中，来解决回调地狱问题。函数调用栈这是一种什么概念呢？我们知道，js内置了一些公共的方法，如setTimeout与setInterval这两个函数，他们有一个特性，就是异步执行。当js执行到此类函数的时候，直接放到栈中（具体如何实现不做详解），当整个同步的js代码执行完成之后，再调用栈中的异步函数，当然这个调用栈也是按放入的顺序去一个一个执行。这样子我们就实现了异步处理按我们想要队列办法来实现。 function fn(){ console.log('fn do!'); } function fn1(fn){ console.log('do 1!'); fn &amp;&amp; setTimeout(fn,0); } function fn2(fn){ console.log('do 2!'); fn &amp;&amp; setTimeout(fn,0); } function fn3(fn){ console.log('do 3!'); fn &amp;&amp; setTimeout(fn,0); } fn1(fn2(fn3(fn))); // 输出结果为： // do 3! // do 2! // do 1! // fn do! 这种实现办法，虽然在一定程序上可以解决掉代码维护上的困难度，不过却影响到可读性。我们从调用的层叠性上看，令人搞不清顺序，从fn1到fn3的层层调用中，我们发现输出结果是先3然后再到1，最后才执行want函数，感觉虽然解决了代码回调地狱，却把顺序弄得不伦不类的。如果这队列上的回调更多，则会更加难以理解。 Promise的基础与使用Promise的引入如果浏览器已经支持了原生的Promise对象，那我们可以将上面的函数都改写为Promse对象的方法。 function fn(){ console.log('fn do!'); } function fn1(fn){ console.log('do 1!'); return new Promise(function(resolve,reject){ if(typeof fn == 'function') resolve(fn); else reject(\"TypeError:\" + fn + \"no a function.\"); }); } function fn2(fn){ console.log('do 2!'); return new Promise(function(resolve,reject){ if(typeof fn == 'function') resolve(fn); else reject(\"TypeError:\" + fn + \"no a function.\"); }); } function fn3(fn){ console.log('do 3!'); return new Promise(function(resolve,reject){ if(typeof fn == 'function') resolve(fn); else reject(\"TypeError:\" + fn + \"no a function.\"); }); } fn1(fn) .then(function(fn){ return fn2(fn); }) .then(function(fn){ return fn3(fn); }) .then(function(fn){ fn(); }); // 执行结果为： // do 1! // do 2! // do 3! // fn do! 从上面的代码中，我们很清楚地看到，fn1是从1-3的顺序去执行，并且代码层次也可以分得非常清晰。这就是Promise的在实际中最基本的实现。 Promise对象为了更好理解Promise，我们把其基础的概念进行解释一下：一、Promise对象有三种状态，分别是： padding:等待中，或进行中，表示还没有得到结果 resolved(Fulfilled): 已经完成，表示得到了我们想要的结果，可以继续往下执行 rejected: 也表示得到结果，但是由于结果并非我们所愿，因此拒绝执行 new Promise(function(resolve, reject) { if(true){ resolve() }; if(false){ reject() }; }) 二、Promise对象中的then方法，可以接收构造函数中处可以接收构造函数中处理的状态变化，并分别对应执行。then方法有2个参数，第一个函数接收resolved状态的执行，第二个参数接收reject状态的执行。 假设：var p = new Promise(resolve,reject)中有两参数，则p.then((data1) =&gt; {},(data2) =&gt; {})，此中data1是resolve执行处理的结果，而data2是reject执行处理的结果。 then方法也会返回一个Promise对象。因此我们就可以进行then的链式调用了。这也是解决回调的主要方式。比如可以这样写： new Promise((resolve,reject) => { if(true){ console.log('resolve'); resolve(); }else{ console.log('reject'); reject(); } }).then(() => { console.log('then 1'); }).then(() => { console.log('then 2'); }) 我们在浏览器控制台上打印new Promise((resolve,reject) =&gt; {})，从原型中可以看到除了then还有一个catch。而then(null,() =&gt; {})就等同于catch(() =&gt; {})。从这个结构上来看，then函数其实也是接受两个参数的。我们可以猜想，在执行异步的队列过程中，每一步都是有返回成功与失败的情况，那么则在每一种情况下都可以执行相应的逻辑代码。 // 伪代码 new Promise((resolve,reject) => {}) .then(() => {}, () => {}) //第一个回调是成功的，第二个是失败的 .then(() => {}, () => {}) ... 或者根据Promise的对象实例接口可以分开来写： // 伪代码 new Promise((resolve,reject) => {}) .then(() => {}) //成功的 .catch(() => {}) //失败的 .then(() => {}) .catch(() => {}) ... 三、Promise.all方法是等待所有Promise都执行完之后才执行的回调函数。比如，很多ajax在被按顺序地执行，当所有ajax都返回值了，这时才去执行all。Promise.all接收一个Promise对象组成的数组作为参数，当这个数组所有的Promise对象状态都变成resolved或者rejected的时候，它才会去调用then方法。并且返回一个Promise对象。 const p1 = new Promise((resolve,reject) => {}); const p2 = new Promise((resolve,reject) => {}); const p3 = new Promise((resolve,reject) => {}); Promise.all([p1,p2,p3]).then(() => { console.log('run Promise all callback!'); }) 四、Promise.race方法则是在一个Promise对象数组中，只要有一个Promise的状态变成resolved或者rejected，也就是说只要有一个执行完成，就可以调用其then方法了。同样Promise.race与是接收一个Promise数组作为参数，并返回一个Promise对象。 const p1 = new Promise((resolve,reject) => {}); const p2 = new Promise((resolve,reject) => {}); const p3 = new Promise((resolve,reject) => {}); Promise.race([p1,p2,p3]).then(() => { console.log('run Promise all callback!'); }) Promise中的数据传递Promise的then会执行之后会返回一个Promise对象，而then方法的两个可选参数是两个回调函数，这两个回调函数都有一个可选参数，实际上，这个参数就是从上一个Promise处理后resolved或者rejected的结果值。 new Promise(function(resolve,reject) { if(true) resolve('resolve 0'); else reject('reject 0'); }).then(function(data){ console.log(data); return \"resolve 1\"; },function(data){ console.log(data); return \"reject 1\"; }).then(function(data){ console.log(data); return \"resolve 2\"; },function(data){ console.log(data); return \"reject 2\"; }).then(function(data){ console.log(data); return \"resolve 3\"; },function(data){ console.log(data); return \"reject 3\"; }).then(function(data){ console.log(data); },function(data){ console.log(data); }); // 打印的结果为： // resolve 0 // resolve 1 // resolve 2 // resolve 3 从上面的结果来看，可以知道，每一个then方法的返回值，都是下一then方法中的回调函数中的参数值。这样内中的值就可以按着我们想要的顺序一步一步地向下传。 Promise在实际中的应用Promise的实际应用是非常广泛的，常见的异步编程中，基本上都可以使用Promise来实现。 应用Promise封装ajax在文章开始的时候，我们做过一个简便的ajax实际，现在我们再利用Promise来实现其过程。 // 简略实现ajax function ajax(url,type){ return new Promise((resolve,reject) => { var XHR = new XHRHttpRequest(); XHR.open(type,url,true); XHR.send(); XHR.onreadystatechange = () => { if(XHR.readyState == 4) { if(XHR.status == 200) { try { let response = JSON.parse(XHR.responseText); resolve(response); } catch(e) { reject(e); } } else { reject(new Error(XHR.statusText)); } } } }); } 为了健壮性，处理了很多可能出现的异常，总之，就是正确的返回结果，就resolve一下，错误的返回结果，就reject一下。并且利用上面的参数传递的方式，将正确结果或者错误信息通过他们的参数传递出来。然后在调用的时候，可以这样使用： // 伪代码 ajax(&lt;url>,&lt;type>).then(response => console.log(response), error => console.log(error)); 现在所有的库几乎都将ajax请求利用Promise进行了封装，因此我们在使用jQuery等库中的ajax请求时，都可以利用Promise来让我们的代码更加优雅和简单。这也是Promise最常用的一个场景，因此我们一定要非常非常熟悉它，这样才能在应用的时候更加灵活。 所以现在的jquery中的$.ajax实际上是可以这样子调用的： $.ajax(&lt;url>).done(callback).error(callback); 总结Promise在实际应用中是非常广泛的，常见的ajax封装，图片异步加载，一些js插件的封装也可以通过异步的实现办法。真正去理解它，还需要不段地练习以相多多查看api文档。这样才能更好利用Promise为你做更多的事。写此文我参考了一些别人的资料，并添加了一些自己的见解，七凑八凑而成。由于我的知识积累有限，有很多地方可能解释得也是不太清楚。在此给一下参考作者的文章：前端进阶：透彻掌握 Promise 的使用，读这篇就够了","tags":[{"name":"es6","slug":"es6","permalink":"https://huangguangjie.github.io/tags/es6/"},{"name":"promise","slug":"promise","permalink":"https://huangguangjie.github.io/tags/promise/"},{"name":"原生对象","slug":"原生对象","permalink":"https://huangguangjie.github.io/tags/原生对象/"}]},{"title":"Redux之中间件applyMiddleware源码解读","date":"2017-03-29T16:00:00.000Z","path":"2017/03/30/redux-applyMiddleware/","text":"在学习了redux过程中，了解到中间件这个名词，但是我看了十遍，也完全就是懵逼的状态。于是又重复敲了几次代码也不能掌握这个东西到底是什么？看官网文档，那么些专业名词，让人半天摸不着头脑。我们从流程图中知道，react组件在执行过程中，特别是在中间插入各种奇怪的需求的时候，不可能每每都是改动一下代码逻辑，而是用一种方便插拔的方式添加进去。但是这个过程说得简单，理解也容易，问题到底是怎么实现的呢？本人这样的半吊子水平，要理解这么高深的东西，真是太困难了。反复地摸索过程中，感觉摸到一些门径，于是斗胆做一下我的解读，如有不对，欢迎斧正！ 前言在学习appleyMiddleware中间件之前，必须要有一些知识储备。列出一下： react redux或者看github上的教程redux-tutorial-cn 源码分析applyMiddleware源码import compose from './compose' export default function applyMiddleware(...middlewares) { return (createStore) => (reducer, preloadedState, enhancer) => { var store = createStore(reducer, preloadedState, enhancer) var dispatch = store.dispatch var chain = [] var middlewareAPI = { getState: store.getState, dispatch: (action) => dispatch(action) } chain = middlewares.map(middleware => middleware(middlewareAPI)) dispatch = compose(...chain)(store.dispatch) return { ...store, dispatch } } } createStore第一次执行applyMiddleware增加中间件，使用闭包保存中间件，然后返回一个函数（一开始我很奇怪为什么参数是createStore？？)，在弄明白applyMiddleware之前，得先来看他是如何被调用的，那就得先从createStore开始看。摘了核心的createStore的源码如下： export default function createStore(reducer, preloadedState, enhancer) { if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'undefined') { enhancer = preloadedState preloadedState = undefined } if (typeof enhancer !== 'undefined') { if (typeof enhancer !== 'function') { throw new Error('Expected the enhancer to be a function.') } return enhancer(createStore)(reducer, preloadedState) } if (typeof reducer !== 'function') { throw new Error('Expected the reducer to be a function.') } ... } 分析源码可以发现其中有一段这样的代码： if (typeof enhancer !== 'undefined') { if (typeof enhancer !== 'function') { throw new Error('Expected the enhancer to be a function.') } return enhancer(createStore)(reducer, preloadedState) } 翻译一下这个参数enhancer英文意思为：“增强器”。我反复看这代码，越看越吃惊，天啊！作者写的这段代码太让人惊叹了！我从未见过如此风骚的代码！ enhancer我们不妨再简化一下这个createStore源码： function createStore(reducer,preloadedState,enhancer){ ... return enhancer(createStore)(reducer,preloadedState) ... } 我们知道，其实enhancer === applyMiddleware，这样子，我们再将enhancer换为applyMiddleware这时变成这样子： function createStore(reducer,preloadedState,enhancer){ ... return applyMiddleware(createStore)(reducer,preloadedState) ... } 这时，我们可以将里面的返回代码拿出来，得出这样的： applyMiddleware(createStore)(reducer,preloadedState) -> &lt;enhancer> 我们可以想一下，执行这段代码会返回什么呢？暂时先不用管，我们假设返回结果为。从函数定义上，执行到此地，就被返回了，也就是到函数到此结束，下面的所有代码都不会执行了。那createStore函数，到这里，就交给了applyMiddleware去处理了。 applyMiddleware我们再回到applyMiddleware的源码上来。看到，定义的applayMiddlware为（简化之后）： function applyMiddleware(...middlewares) { return (createStore) => (reducer, preloadedState, enhancer) => { // ... } } 然后我们不妨一步一步调用此函数： // step1 const step1 = applyMiddleware(...middlewares) //返回 function(createStore){} // step2 const step2 = step1(createStore) //返回 function(reducer,preloadedState,enhancer){} // step2的返回值即为 const step3 = function(reducer,preloadedState,enhancer){} // 对比createStore的定义 function createStore(reducer,preloadedState,enhancer){} 我们在此可以惊奇地发现，原来，createStore函数居然可以通过applyMiddleware返回的！！！那在此，可以得出，createStore(reducer,preloadedState,enhancer)执行之后，如果enhancer未传，那么就是普通的createStore了，如果传了，那实际上，createStore已经被enhancer接管了，然后相当于再返回一个普通的createStore而已。这才是其中的精妙之处！ 我们再来看一下我们平时调用createStore时的方式是这样的： createStore( rootReducers, //reducer preloadedState, applyMiddleware( //enhancer thunkMiddleware, createLogger ) ) 可以将里面的applyMiddleware替换为&lt;enhancer&gt;，然后与上面的对比： createStore(reducer,preloadedState,&lt;enhancer>) // 实际上，enhancer传了参，那么返回的结果实际上也是一个普通的 createStore 在第一次调用createStore的时候，createStore先判断是否有middlewares(enhancer)的加入，如果有，就不执行createStore后面的操作，return出去执行enhancer()。这里换一种说法： 执行createStore的时候，只要传了中间件applyMiddleware这样的合法参数，那么，就相当于createStore被改写了，实际返回时，也是一个createStore方法，然后执行之后，与普通的是一样的，而且中间可以随意添加移除各种需求的逻辑组件。此种实现方法被冠以一个名词：柯里化(Currying)，就是将多参变成单参的函数，也就是通过函数链的方式进行返回以达到单参函数。这就是applyMiddleware中间件的核心价值！ 注意：执行了enhancer(createStore)后，只传入两个参数(reducer,preloadedState)，第三个参数 enhancer为undefined store执行enhancer就要回过头看applyMiddleware源码。实际上执行enhancer，返回就是我们要的createStore函数！ function applyMiddleware(...middlewares) { return (createStore) => (reducer, preloadedState, enhancer) => { // ... return { ...store, dispatch } } } //执行之后，返回值为createStore函数： function(reducer, preloadedState, enhancer){} 由于没有第三个参数enhancer，所以这才是真正执行createStore()，返回一个没有 middleware的store。我们可以看一下applyMiddleware里面有一个语句： ... var store = createStore(reducer, preloadedState, enhancer) ... 在这里，可以看出，在内部，也执行了createStore函数的调用，也就是说，createStore将实现移交给了applyMiddleware之后，在applyMiddleware内部同样会生成普通的store对象的。同样，如果这里的enhancer如果存在，继续循环原先的步骤。 middleware我们继续看内部的源码为： ... var dispatch = store.dispatch var chain = [] var middlewareAPI = { getState: store.getState, dispatch: (action) => dispatch(action) } chain = middlewares.map(middleware => middleware(middlewareAPI)) ... 定义了一个chain数组，存放每一个被处理过的middleware。代码可以这样解释：首先为每一个middleware以{getState，dispatch}为参数执行一遍，其实是为了给middleware一个原生的{getState，dispatch}两个方法的指针，以便在middleware中调用。而上面的applyMiddleware的参数中就有两个参数：thunkMiddleware,createLogger，他们都是middleware。他们在传入applyMiddleware的过程中，都被包装过一次，并且存放在chain数组中。请看一个简单的middleware： const logger = ({getState,dispatch}) => next => action { console.log('dispatching',action) let result = next(action) console.log('next state',getState()) return result } 调用后返回的chain是一个以next为参数的函数数组: chain = [logger].map(middleware => middleware({ getState:store.getState, dispatch:(action) => dispatch(action) })) compose继续看代码，有一个这样的语句： ... dispatch = compose(...chain)(store.dispatch) ... dispatch被compose包装之后，重新赋值给自身。但这段语句看得莫名莫妙。这是什么鬼意思？干嘛用的？ 这里，不妨来看一下compose源码 export default function compose(...funcs) { if (funcs.length === 0) { return arg => arg } if (funcs.length === 1) { return funcs[0] } const last = funcs[funcs.length - 1] const rest = funcs.slice(0, -1) return (...args) => rest.reduceRight((composed, f) => f(composed), last(...args)) } 其中一段为： return (...args) => rest.reduceRight((composed, f) => f(composed), last(...args)) 看到这段，更加头疼。。。反正看来看去。大体意思是这样：compose 可以接受一组函数参数，从右到左来组合多个函数，然后返回一个组合函数。也就是说，compose接收chain这个数组，然后用reduceRight函数进行组合，最终合成了一个新的函数，只能这么理解了。 dispatch到这里，也就是说，dispatch已经被compose重新组装过一次，在最后，再被组装成一个新的store返回。 ... return { ...store, dispatch } 结论middleware内部的dispatch是原生的没有middleware时的dispatch，每一个middleware都带有原生的getState，dispatch和next（下一个middleware），所以我可以在middleware中不调用next，而直接调用dispatch，就跳过了后面的middleware了。applyMiddleware中间件，其实就是将createStore接管了，然后在最终返回一个store对象。每一个中间件都是做这样的一件事情，这样，就可以源源不断地往里面添加需求或者移出需求，而不必修改流程代码上的任何逻辑。仅此而已！","tags":[{"name":"react","slug":"react","permalink":"https://huangguangjie.github.io/tags/react/"},{"name":"redux","slug":"redux","permalink":"https://huangguangjie.github.io/tags/redux/"}]},{"title":"Yarn,或将取代npm客户端","date":"2017-03-28T16:00:00.000Z","path":"2017/03/29/yarn-article/","text":"Yarn 是一个新的包管理器，用于替代现有的 npm 客户端或者其他兼容 npm 仓库的包管理工具。Yarn 保留了现有工作流的特性，优点是更快、更安全、更可靠。 为什么用yarn非常快，非常非常快yarn 缓存了每次你下载的模块，所以同样模块同样的版本不会发送第二次下载请求，对于没有缓存的模块， yarn 也可以通过并行的网络请求最大限度利用网络资源。现在真的是没有什么几十秒安装不完的依赖的。一个 50 个依赖的 webpack + babel 项目可以在 20 秒左右安装完成。 安全yarn在开始安装一个包之前会先用 checksums 来验证，你不用担心本地的缓存的包被破坏了导致安装失败。 可靠被一群喜欢喵星人的开发者维护，以及有 FaceBook 在 production 环境中使用。完善的测试和基于 flow type 的 code base。保证各平台依赖的一致性。 网络优化力求网络资源最大利用化，让资源下载完美队列执行，避免大量的无用请求，下载失败会自动重新请求，避免整个安装过程失败 扁平化模式对于不匹配的依赖版本的包创立一个独立的包，避免创建重复的。 以及很多令人感动的小改进 有些 npm 包会抛出 warning 提示信息，在一起 npm install 的时候只有一个名字你完全不知道是哪个包的哪个包的哪个包抛出的这个信息，而 yarn 改善了这一点。 yarn ls 会高亮出所有在 package.json 的 dependencies 里的依赖，增强可读性。 每一条命令都会显示执行的时间。 默认生成 lockfile . 保证 yarn 每次安装相同版本的依赖，npm shrinkwrap 会丧失掉同步性如果你忘了生成它。 yarn why &lt;name&gt; 这条命令可以告诉你为什么一个依赖会被安装到你的项目中。 安装安装yarn其实非常简单，可以使用npm进行安装yarn包。其官网也有相应的安装文档:yarn docs $ npm install -g yarn 安装完成之后可以查看版本号 $ yarn --version 或者 $ yarn -v 使用初始化切换到自己的项目目录，执行 $ yarn init 然后照着提示依次输入参数就OK了。如果觉得麻烦，可以直接执行 $ yarn init -y 这样可以直接创建最简的一个项目。其中包含了package.json文件。 添加包依赖接下来可以直接在此添加包依赖了,会自动安装最新版本，注意会覆盖指定版本号 $ yarn add [package]@[version] 或者 $ yarn add [package]@[tag] 你会发现，在客户端会打印一出一堆信息如下，添加jquery依赖： $ yarn add jquery yarn add v0.21.3 info No lockfile found. [1/4] Resolving packages... [2/4] Fetching packages... [3/4] Linking dependencies... █████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ █████████████████████████████████░░░░░░░░░░░░░ ████████████████████████████████████████ ████████████████████████████████████████ [4/4] Building fresh packages... success Saved lockfile. success Saved 1 new dependency. └─ jquery@3.2.1 Done in 4.28s. 这时在当前目录中自动添加了一个yarn.lock文件，用于记录所有的包依赖信息。 更新包依赖更新某包 $ yarn update [package] 更新指定版本的包 $ yarn update [package]@[version] 更新到指定某个标签上的包 $ yarn update [package]@[tag] 移除依赖$ yarn remove [package] 后面的参数可以与更新包的类似。 开工在多人团队协作的时候，拉到代码之后，可以类似于npm一样，执行 $ yarn install 即可以开工啦！ 总结yarn管理器有一个很重要的文件需要注意，就是yarn.lock，这个是用来依赖的正确性，快速可靠安装的；是执行cli的时候自动生成的，在项目的根目录下，需要保留！！！！不要编辑它，这是自动生成的","tags":[{"name":"yarn","slug":"yarn","permalink":"https://huangguangjie.github.io/tags/yarn/"},{"name":"npm","slug":"npm","permalink":"https://huangguangjie.github.io/tags/npm/"},{"name":"node","slug":"node","permalink":"https://huangguangjie.github.io/tags/node/"}]}]